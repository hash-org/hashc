<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Patterns - The Hash Programming Language</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../features/intro.html"><strong aria-hidden="true">2.</strong> Language features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../features/name-bindings.html"><strong aria-hidden="true">2.1.</strong> Name bindings</a></li><li class="chapter-item expanded "><a href="../features/functions.html"><strong aria-hidden="true">2.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../features/primitives.html"><strong aria-hidden="true">2.3.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="../features/control-flow.html"><strong aria-hidden="true">2.4.</strong> ðŸš§ Control flow</a></li><li class="chapter-item expanded "><a href="../features/operators.html"><strong aria-hidden="true">2.5.</strong> ðŸš§ Operators</a></li><li class="chapter-item expanded "><a href="../features/types.html"><strong aria-hidden="true">2.6.</strong> ðŸš§ Types</a></li><li class="chapter-item expanded "><a href="../features/structs-enums.html"><strong aria-hidden="true">2.7.</strong> Structs and enums</a></li><li class="chapter-item expanded "><a href="../features/modules.html"><strong aria-hidden="true">2.8.</strong> Modules and visibility</a></li><li class="chapter-item expanded "><a href="../features/patterns.html" class="active"><strong aria-hidden="true">2.9.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="../features/traits-impls.html"><strong aria-hidden="true">2.10.</strong> Traits and implementations</a></li><li class="chapter-item expanded "><a href="../features/type-functions.html"><strong aria-hidden="true">2.11.</strong> Type functions</a></li><li class="chapter-item expanded "><a href="../features/memory.html"><strong aria-hidden="true">2.12.</strong> ðŸš§ Memory management</a></li><li class="chapter-item expanded "><a href="../features/directives.html"><strong aria-hidden="true">2.13.</strong> ðŸš§ Directives</a></li></ol></li><li class="chapter-item expanded "><a href="../standard-library/intro.html"><strong aria-hidden="true">3.</strong> Standard library</a></li><li class="chapter-item expanded "><a href="../interpreter/intro.html"><strong aria-hidden="true">4.</strong> Interpreter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../interpreter/options.html"><strong aria-hidden="true">4.1.</strong> Interpreter options</a></li><li class="chapter-item expanded "><a href="../interpreter/backends.html"><strong aria-hidden="true">4.2.</strong> Compiler backends</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced/intro.html"><strong aria-hidden="true">5.</strong> Advanced concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/compiler-internals.html"><strong aria-hidden="true">5.1.</strong> Compiler internals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../advanced/loop-transpilation.html"><strong aria-hidden="true">5.1.1.</strong> Loop transpilation</a></li><li class="chapter-item expanded "><a href="../advanced/if-statement-transpilation.html"><strong aria-hidden="true">5.1.2.</strong> If statement transpilation</a></li><li class="chapter-item expanded "><a href="../advanced/type-inference.html"><strong aria-hidden="true">5.1.3.</strong> Type inference</a></li></ol></li><li class="chapter-item expanded "><a href="../advanced/future-features.html"><strong aria-hidden="true">5.2.</strong> Future features</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Hash Programming Language</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/hash-org/lang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<p>Pattern matching is a very big part of <code>Hash</code> and the productivity of the language.
Patterns are a declarative form of equality checking, similar to patterns in Rust or Haskell.</p>
<p>Pattern matching within <code>match</code> statements is more detailed within the <a href="./conditionals.html#match-cases">Conditional statements</a> section
of the book.
This chapter is dedicated to documenting the various kinds of patterns that there are in Hash.</p>
<h2 id="literal-patterns"><a class="header" href="#literal-patterns">Literal patterns</a></h2>
<p>Literal patterns are patterns that match a specific value of a primitive type, like a number or a string.
For example, consider the following snippet of code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo := get_foo(); // foo: i32

match foo {
    1 =&gt; print(&quot;Got one&quot;);
    2 =&gt; print(&quot;Got two&quot;);
    3 =&gt; print(&quot;Got three&quot;);
    _ =&gt; print(&quot;Got something else&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>On the left-hand side of the match cases there are the literal patterns <code>1</code>, <code>2</code> and <code>3</code>.
These perform <code>foo == 1</code>, <code>foo == 2</code> and <code>foo == 3</code> in sequence, and the code follows the branch which succeeds first.
If no branch succeeds, the <code>_</code> branch is followed, which means &quot;match anything&quot;.
Literals can be integer literals for integer types (signed or unsigned), string literals for the <code>str</code> type, or character literals for the <code>char</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match my_char {
    'A' =&gt; print(&quot;First letter&quot;);
    'B' =&gt; print(&quot;Second letter&quot;);
    x =&gt; print(&quot;Letter is: &quot; + conv(x));
}

match my_str {
    &quot;fizz&quot; =&gt; print(&quot;Multiple of 3&quot;);
    &quot;buzz&quot; =&gt; print(&quot;Multiple of 5&quot;);
    &quot;fizzbuzz&quot; =&gt; print(&quot;Multiple of 15&quot;);
    _ =&gt; print(&quot;Not a multiple of 3 or 5&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="binding-patterns"><a class="header" href="#binding-patterns">Binding patterns</a></h2>
<p>Nested values within the value being pattern matched can be bound to symbols, using binding patterns.
A binding pattern is any valid Hash identifier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match fallible_operation() { // fallible_operation: () -&gt; Result&lt;f32, i32&gt;
    Ok(success) =&gt; print(&quot;Got success &quot; + conv(result)); // success: f32
    Err(failure) =&gt; print(&quot;Got failure &quot; + conv(failure)); // failure: i32
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="tuple-patterns"><a class="header" href="#tuple-patterns">Tuple patterns</a></h2>
<p>Tuple patterns match a tuple type of some given arity, and contain nested patterns.
They are irrefutable if their inner patterns are irrefutable, so they can be used in declarations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Cat := struct(name: str);

// Creating a tuple:
my_val := (Cat(&quot;Bob&quot;), [1, 2, 3]); // my_val: (Cat, [i32])

// Tuple pattern:
(Cat(name), elements) := my_val;

assert(name == &quot;Bob&quot;);
assert(elements == [1, 2, 3]);
<span class="boring">}
</span></code></pre></pre>
<h2 id="constructor-patterns"><a class="header" href="#constructor-patterns">Constructor patterns</a></h2>
<p>Constructor patterns are used to match the members of structs or enum variants.
A struct is comprised of a single constructor, while an enum might be comprised of multiple constructors.
Struct constructors are irrefutable if their inner patterns are irrefutable, while enum constructors are irrefutable only if the enum contains a single variant.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Option := &lt;T&gt; =&gt; enum(Some(value: T), None);

my_val := Some(&quot;haha&quot;);

match my_val {
    // Matching the Some(..) constructor
    Some(inner) =&gt; assert(inner == &quot;haha&quot;); // inner: str
    // Matching the None constructor
    None =&gt; assert(false);
}
<span class="boring">}
</span></code></pre></pre>
<p>The names of the members of a constructor need to be specified if the matching isn't done in order:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Dog := struct(name: str, breed: str);

Dog(breed = dog_breed, name = dog_name) = Dog(
    name = &quot;Bob&quot;,
    breed = &quot;Husky&quot;
) // dog_breed: str, dog_name: str

// Same as:
Dog(name, breed) = Dog(
    name = &quot;Bob&quot;,
    breed = &quot;Husky&quot;
) // breed: str, name: str
<span class="boring">}
</span></code></pre></pre>
<h2 id="list-patterns"><a class="header" href="#list-patterns">List patterns</a></h2>
<p>A list pattern can match elements at certain positions of a list by using the following syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match arr {
    [a, b] =&gt; print(conv(a) + &quot; &quot; + conv(b));
    _ =&gt; print(&quot;Other&quot;); // Matches everything other than [X, Y] for some X and Y
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>...</code> spread operator can be used to capture or ignore the rest of the elements of the list at some position:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match arr {
    [a, b, ...] =&gt; print(conv(a) + &quot; &quot; + conv(b));
    _ =&gt; print(&quot;Other&quot;); // Only matches [] and [X] for some X
}
<span class="boring">}
</span></code></pre></pre>
<p>If you want to match the remaining elements with some pattern, you can specify a pattern after the <code>spread</code> operator like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match arr {
    [a, b, ...rest] =&gt; print(conv(a) + &quot; &quot; + conv(b) + &quot; &quot; + conv(rest));
    [...rest, c] =&gt; print(conv(c)); // Only matches [X] for some X, rest is always []
    _ =&gt; print(&quot;Other&quot;); // Only matches []
}
<span class="boring">}
</span></code></pre></pre>
<p>One obvious limitation of the <code>spread</code> operator is that you can only use it once in the list pattern.
For example, the following pattern will be reported as an error by the compiler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[..., a, ...] := arr;
<span class="boring">}
</span></code></pre></pre>
<pre><code>error: Failed to typecheck:
 --&gt; 1:6 - 1:9, 1:15 - 1:18
  |
1 | [..., a, ...] := arr;
  |  ^^^     ^^^
  |
  = You cannot use multiple spread operators within a single list pattern.
</code></pre>
<h2 id="module-patterns"><a class="header" href="#module-patterns">Module patterns</a></h2>
<p>Module patterns are used to match members of a module.
They are used when importing symbols from other modules.
They follow a simple syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// imports only a and b from the module
{a, b} := import(&quot;./my_lib&quot;);

// imports c as my_c, and d from the module.
{c as my_c, d} := import(&quot;./other_lib&quot;); 

// imports Cat from the nested module as NestedCat
{Cat as NestedCat} := mod {
    pub Cat := struct(name: str, age: i32);
};
<span class="boring">}
</span></code></pre></pre>
<p>You do not need to list all the members of a module in the pattern; the members which are not listed will be ignored.
To read more about modules, you can click <a href="./modules.html">here</a>.</p>
<h2 id="or-patterns"><a class="header" href="#or-patterns">Or-patterns</a></h2>
<p>Or-patterns are specified using the <code>|</code> pattern operator, and allow one to match multiple different patterns, and use the one which succeeds.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>symmetric_result: Result&lt;str, str&gt; := Ok(&quot;bilbobaggins&quot;);

(Ok(inner) | Err(inner)) := symmetric_result; // inner: str
<span class="boring">}
</span></code></pre></pre>
<p>The pattern above is irrefutable because it matches all variants of the <code>Result</code> enum.
Furthermore, each branch has the binding <code>inner</code>, which always has the type <code>str</code>, and so is a valid pattern.
The same name binding can appear in multiple branches of an or-pattern, given that it is bound in every branch, and always to the same type.
Another use-case of or-patterns is to collapse match cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match color {
    Red | Blue | Green =&gt; print(&quot;Primary additive&quot;);
    Cyan | Magenta | Yellow =&gt; print(&quot;Primary subtractive&quot;);
    _ =&gt; print(&quot;Unimportant color&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="conditional-patterns"><a class="header" href="#conditional-patterns">Conditional patterns</a></h2>
<p>Conditional patterns allow one to specify further arbitrary boolean conditions to a pattern for it to match:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match my_result {
    Ok(inner) if inner &gt; threshold * 2.0 =&gt; {
        print(&quot;Phew, above twice the threshold&quot;);
    };
    Ok(inner) if inner &gt; threshold =&gt; {
        print(&quot;Phew, above the threshold but cutting it close!&quot;);
    };
    Ok(inner) =&gt; {
        print(&quot;The result was successful but the value was below the threshold&quot;);
    };
    Err(_) =&gt; {
        print(&quot;The result was unsuccessful... Commencing auto-destruct sequence.&quot;);
        auto_destruct();
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>They are specified using the <code>if</code> keyword after a pattern.
Conditional patterns are always refutable, at least as far as the current version of the language is concerned.
With more advanced type refinement and literal types, this restriction can be lifted sometimes.</p>
<h2 id="pattern-grouping"><a class="header" href="#pattern-grouping">Pattern grouping</a></h2>
<p>Patterns can be grouped using parentheses <code>()</code>.
This is necessary in declarations for example, if one wants to specify a conditional pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// get_value: () -&gt; bool;
true | false := get_value(); // Error: bitwise-or not implemented between `bool` and `void`
(true | false) := get_value(); // Ok
<span class="boring">}
</span></code></pre></pre>
<h2 id="grammar"><a class="header" href="#grammar">Grammar</a></h2>
<p>The grammar for patterns is as follows:</p>
<pre><code>pattern = 
    | single_pattern
    | or_pattern

single_pattern =
    | binding_pattern
    | constructor_pattern
    | tuple_pattern
    | module_pattern
    | literal_pattern
    | list_pattern

or_pattern = ( single_pattern &quot;|&quot; )+ single_pattern

binding_pattern = identifier

tuple_pattern_member = identifier | ( identifier &quot;=&quot; single_pattern )

constructor_pattern = access_name ( &quot;(&quot; ( tuple_pattern_member &quot;,&quot; )* tuple_pattern_member? &quot;)&quot; )?

tuple_pattern = 
    | ( &quot;(&quot; ( tuple_pattern_member &quot;,&quot; )+ tuple_pattern_member? &quot;)&quot; ) 
    | ( &quot;(&quot; tuple_pattern_member &quot;,&quot; &quot;)&quot; )

module_pattern_member = identifier ( &quot;as&quot; single_pattern )?

module_pattern = &quot;{&quot; ( module_pattern_member &quot;,&quot; )* module_pattern_member? &quot;}&quot;

literal_pattern = integer_literal | string_literal | character_literal | float_literal

list_pattern_member = pattern | ( &quot;...&quot; identifier? )

list_pattern = &quot;[&quot; ( list_pattern_member &quot;,&quot; )* list_pattern_member? &quot;]&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../features/modules.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../features/traits-impls.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../features/modules.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../features/traits-impls.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
