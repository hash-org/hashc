//
// The Hash programming language standard library sources.
//
// Module: "prelude"
//
// Description: Critical runtime module that is imported into any Hash
// runtime by default. This module defines all the bindings between the
// compiler interals and the program runtime.

Intrinsics := #intrinsics mod {
    pub add_i32 : (a: i32, b: i32) -> i32;
};


// Equality
Eq := <Rhs> => trait {
    Self: Type;

    eq: (&Self, &Rhs) -> bool;
};

NotEq := trait {
    Self : Type ~ Eq<i32>;

    // not_eq := (a: &Self, b: &Self) -> bool => Self::eq(a, b);
};

// Ordering
// Implemented for numeric primitives and strings.
Ordering := enum( Lt, Eq, Gt, );

// Eq ~= impl Eq<Ordering> {
//     eq := (a, b) => match (a, b) {
//         (Eq, Eq) => true;
//         (Lt, Lt) => true;
//         (Gt, Gt) => true;
//         _ => false;
//     };
// };

Ord := <T> => trait {
    ord: (a: T, b: T) -> Ordering;
    // gt := (a: T, b: T) => a.ord(b) == Ordering::Gt;
    // lt := (a: T, b: T) => a.ord(b) == Ordering::Lt;
    // gt_eq := (a: T, b: T) => a.ord(b) != Ordering::Lt;
    // lt_eq := (a: T, b: T) => a.ord(b) != Ordering::Gt;
};


// Convert some type `T` into a `u64`. Hashing trait.
Hash := <T> => trait {
    hash : (item: &T) -> u64;
};

// Add operator (+)
// Implemented for all numeric primitives, strings, lists.
Add := trait {
    Self: Type;

    add: (Self, Self) -> Self;
};

i32 := i32 ~ impl Add {
    Self := i32;

    add := (a: i32, b: i32) => Intrinsics::add_i32(a, b);
};

// Subtract operator (-)
Sub := <T> => trait {
    sub: (T, T) -> T;
};

// Multiply operator (*)
Mul := <T> => trait {
    mul: (T, T) -> T;
};

// Mul ~= impl Mul<int>   { mul := (left, right) => intrinsic_mul(left, right); };
// Mul ~= impl Mul<float> { mul := (left, right) => intrinsic_mul(left, right); };

// Divide operator (/)
Div := <T> => trait {
    div: (T, T) -> T;
};

// Div ~= impl Div<int>   { div := (left, right) => intrinsic_div(left, right); };
// Div ~= impl Div<float> { div := (left, right) => intrinsic_div(left, right); };

// Modulus operator (%)
Mod := <T> => trait {
    modulo: (T, T) -> T;
};

// Mod ~= impl Mod<int>   { modulo := (left, right) => intrinsic_mod(left, right); };
// Mod ~= impl Mod<float> { modulo := (left, right) => intrinsic_mod(left, right); };

// Negation (-)
Neg := <T> => trait {
    neg: (T) -> T;
};

// Neg ~= impl Neg<int>   { neg := (item) => intrinsic_neg(item); };
// Neg ~= impl Neg<float> { neg := (item) => intrinsic_neg(item); };

And := <T> => trait {
    and: (T, T) -> bool;
};

Or := <T> => trait {
    or: (T, T) -> bool;
};


// // Bitwise shift right (<<)
BitShr := <T> => trait {
    bit_shr: (T, T) -> T;
};

// BitShr := impl BitShr<int> {bit_shr := (a, b) => #intrinsic_bit_shr(a, b); };

// Bitwise shift left (>>)
BitShl := <T> => trait {
    bit_shl: (T, T) -> T;
};

// BitShl := impl BitShl<int> {bit_shl := (a, b) => #intrinsic_bit_shl(a, b); };

// Bitwise or (|)
BitOr  := <T> => trait {
    bit_or: (T, T) -> T;
};

// BitOr  := impl BitOr <int> {bit_or  := (a, b)=> #intrinsic_bit_or(b); };

// Bitwise exclusice or (^)
BitXor := <T> => trait {
    bit_xor: (T, T) -> T;
};

// BitXor := impl BitXor<int> {bit_xor := (a, b)=> #intrinsic_bit_xor(b); };

// Bitwise not (~)
BitNot := <T> => trait {
    bit_not: (T) -> T;
};

// BitNot := impl BitNot<int> {bit_not := (a) => #intrinsic_bit_not(a); };

// Bitwise and (&)
BitAnd := trait {
    Self: Type;

    bit_and: (Self, Self) -> Self;
};

Exp := <A, B> => trait {
    exp: (A, B) -> A;
};

// Convert type A to type B
Conv := <A, B> => trait {
    conv : (item: A) -> B;
};

// we provide a number of implementations for converting types

// // Enum primitive conv
// Conv ~= <A: Conv<str>, B: Conv<str>> => impl Conv<Result<A, B>, str> {
//     conv := (res: Result<A, B>) => match res {
//         Ok(a) => "Ok(" + conv(a) + ")";
//         Err(b) => "Err(" + conv(b) + ")";
//     };
// };

// Conv ~= <A: Conv<str>> => impl Conv<Option<A>, str> {
//     conv := (res) => match res {
//         Some(a) => "Somw(" + conv(a) + ")";
//         None => "None";
//     };
// };

// Conv ~= impl Conv<u64, f64> {
//     conv := (item) => intrinsic_conv_to_float(num);
// };

// // Fallible conversion methods for float, int, char from a `str`
// Conv ~= impl Conv<str, Result<float, str>> {
//     conv := (s) => #intrinsic_conv_to_float(s);
// };

// Conv ~= impl Conv<str, Result<int, str>> {
//     conv := (s) => intrinsic_conv_to_int(s);
// };

// Conv ~= impl Conv<int, Result<char, str>> {
//     conv := (s) => intrinsic_conv_to_char(s);
// };

// Conv ~= impl Conv<char, int> {
//     conv := (ch) => intrinsic_conv_to_int(ch);
// };

// Conv ~= impl Conv<float, int> {
//     conv := (num) => intrinsic_conv_to_int(num);
// };

// Conv ~= impl Conv<str, Result<int, str>> {
//     conv := (s) => intrinsic_conv_to_int(s);
// };

// Conv ~= impl Conv<bool, str> {
//     conv := (x) => match x {
//     true => "true";
//     false => "false";
//     };
// };

// Conv ~= impl Conv<int, str> { conv := (num) => intrinsic_conv_to_str(num); };
// Conv ~= impl Conv<float, str> { conv := (num) => intrinsic_conv_to_str(num); };
// Conv ~= impl Conv<char, str> { conv := (ch) => intrinsic_conv_to_str(ch); };
// Conv ~= impl Conv<void, str> { conv := (v) => ""; };

// Conv ~= impl Conv<{A:B}, str> {
//     conv := (map) => intrinsic_conv_map_to_str(
//         map,
//         (a) => conv<A, str>(a),
//         (b) => conv<B, str>(b)
//     );
// };

// Conv ~= impl Conv<{A}, str> {
//     conv := (set) => intrinsic_conv_bracketted_to_str(set, (a) => conv<A, str>(a));
// };

// Conv ~= impl Conv<[A], str> {
//     conv := (arr) => intrinsic_conv_bracketted_to_str(arr, (a) => conv<A, str>(a));
// };

// Hash ~= impl Hash<int> {
//     hash := (num) => #intrinsic_hash(num);
// };

// Hash ~= impl Hash<float> {
//     hash := (num) => #intrinsic_hash(num);
// };

// Hash ~= impl Hash<char> {
//     hash := (ch) => #intrinsic_hash(ch);
// };

// Hash ~= impl Hash<str> {
//     hash := (string) => #intrinsic_hash(string);
// };



// Index := <T, I, O> => trait {
//     index : (T, I) -> O;
// };

// IndexMut := <T, I> => trait {
//     index_mut : (T, I, O) -> void;
// };

// Add ~= impl Add<int>   { add := (left, right) => intrinsic_add(left, right); };
// Add ~= impl Add<float> { add := (left, right) => intrinsic_add(left, right); };
// Add ~= impl Add<str>   { add := (left, right) => intrinsic_add(left, right); };
// Sub ~= impl Sub<int>   { sub := (left, right) => intrinsic_sub(left, right); };
// Sub ~= impl Sub<float> { sub := (left, right) => intrinsic_sub(left, right); };

// Eq ~= impl Eq<int> {
//     eq := (a, b) => intrinsic_eq(a, b);
// };

// Eq ~= impl Eq<char> {
//     eq := (a, b) => intrinsic_eq(a, b);
// };

// Eq ~= impl Eq<float> {
//     eq := (a, b) => intrinsic_eq(a, b);
// };

// Eq ~= impl Eq<str> {
//     eq := (a, b) => intrinsic_eq(a, b);
// };

// Eq ~= <A: Eq> => impl Eq<[A]> {
//     eq := (a, b) => intrinsic_eq_bracketted(a, b, (x, y) => eq<A>(x, y));
// };

// pub _int_to_ord := (i: int) -> Ordering => match i {
//     0 => Eq;
//     1 => Lt;
//     x if x == -1 => Gt;
//     _ => unreachable();
// };


// Ord ~= impl Ord<int> { ord := (a, b) => _int_to_ord(intrinsic_ord(a, b)); };
// Ord ~= impl Ord<char> { ord := (a, b) => _int_to_ord(intrinsic_ord(a, b)); };
// Ord ~= impl Ord<float> { ord := (a, b) => _int_to_ord(intrinsic_ord(a, b)); };
// Ord ~= impl Ord<str> { ord := (a, b) => _int_to_ord(intrinsic_ord(a, b)); };

// Indexing
// Implemented for maps and lists.


// Index ~= impl Index<[T], usize, T> { index := (arr, index) => intrinsic_index_get(arr, index); };
// Index ~= impl Index<{A:B}, A, B> { index := (map, index) => intrinsic_index_map_get(map, index); };

// IndexMut ~= impl IndexMut<[T], usize, T> { index := (arr, index, value) => intrinsic_index_mut(arr, index, value); };
// IndexMut ~= impl IndexMut<{A:B}, A, B> { index := (map, index, value) => intrinsic_index_map_mut(map, index, value); };

// // Index a string, returning a character
// Index ~= impl Index<str, int, char> {
//     index := (string, idx) => intrinsic_index_get(string, idx);
// };


// append an item to a list
// Sequence := <A: Eq> => trait {
//     inner := type A;

//     try_get : (Self, usize) -> Option<A>;
//     push: (Self, A) -> void;
//     push_front: (Self, A) -> void;
//     pop: (Self) -> A;
//     contains: (Self, A) -> bool;
//     insert: (Self, A, usize) -> void;
//     remove: (Self, usize) -> void;
// };

// Sequence ~= impl Sequence<[A]> {
//     try_get := (list, item) => intrinsic_list_try_get(list, item);
//     push := (list, item) => intrinsic_list_push(list, item);
//     push_front := (list, item) => intrinsic_list_push_front(list, item);
//     pop := (list) => intrinsic_list_pop(list);
//     contains := (list, item) => intrinsic_contains(list, item);
//     insert := (list, item, index) => intrinsic_list_insert(list, item, index);
//     remove := (list, index) => intrinsic_list_remove(list, index);
// };
// The Hash programming language standard library sources.
//
// Module: "prelude"
//
// Description: Critical runtime module that is imported into any Hash
// runtime by default. This module defines all the bindings between the
// compiler interals and the program runtime.

