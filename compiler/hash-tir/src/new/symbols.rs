//! Definitions related to symbols and names.

use std::fmt::Display;

use hash_source::identifier::Identifier;
use hash_utils::{
    new_store_key,
    store::{DefaultStore, Store, StoreKey},
};

use super::environment::env::{AccessToEnv, WithEnv};

/// The data carried by a symbol.
///
/// For each context, each distinct member in the context will be given a
/// different `SymbolId`. `SymbolId`s are never "shadowed" like names in a scope
/// stack might; new ones are always created for names that might shadow
/// previous names.
///
/// For example:
/// ```notrust
/// {
///     foo := 3 // -- SymbolId(72)
///     {
///         foo := 4 // -- SymbolId(73)
///     }
/// }
/// ```
///
///
/// This is used to avoid needing to perform alpha-conversion on terms when
/// performing substitutions.
#[derive(Debug, Clone, Copy)]
pub struct SymbolData {
    /// The symbol itself
    pub symbol: Symbol,
    /// A symbol might originate from an identifier name.
    ///
    /// If this is `None`, then the symbol is "internal"/generated by the
    /// compiler, and cannot be referenced by the user.
    pub name: Option<Identifier>,
}

new_store_key!(pub Symbol);
pub type SymbolStore = DefaultStore<Symbol, SymbolData>;

impl Display for WithEnv<'_, Symbol> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.stores().symbol().map_fast(self.value, |data| match data.name {
            Some(name) => write!(f, "{name}"),
            None => write!(f, "s{}", data.symbol.to_index()),
        })
    }
}
