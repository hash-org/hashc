//! Defines the type wrapper for TIR nodes, which contains some
//! metadata about the node, and the data itself.
//!
//! The metadata includes the node origin, which points to the
//! AST node that the TIR node was generated from, if any.
//!
//! Nodes normally live in stores, which can be created through the
//! `crate::environment::stores::tir_node_*` macros.
use hash_ast::ast::AstNodeId;
use hash_source::{location::Span, SourceId};
use hash_storage::store::statics::SingleStoreValue;
use hash_utils::derive_more::{Deref, DerefMut};

use crate::ast_info::HasNodeId;

/// Represents a node in the TIR.
///
/// Each node has an origin, and data associated with it.
#[derive(Debug, Deref, DerefMut, Copy, Clone, PartialEq, Eq)]
pub struct Node<Data> {
    pub origin: NodeOrigin,
    #[deref]
    #[deref_mut]
    pub data: Data,
}

/// Helper implementation for `Node`s which are also `SingleStoreValue`s,
/// so that a node and its entry in the store can be created in one go.
impl<Data> Node<Data>
where
    Self: SingleStoreValue,
{
    /// Create a new node with the given data and origin, and insert it into the
    /// store.
    pub fn create_at(data: Data, origin: NodeOrigin) -> <Self as SingleStoreValue>::Id {
        Self::create(Self::at(data, origin))
    }

    /// Create a new node with the given data and a generated origin, and insert
    /// it into the store.
    pub fn create_gen(data: Data) -> <Self as SingleStoreValue>::Id {
        Self::create(Self::gen(data))
    }
}

impl<Data> Node<Data> {
    /// Create a new node with the given data and origin.
    pub fn at(data: Data, origin: NodeOrigin) -> Self {
        Self { data, origin }
    }

    /// Create a new node with the given data and a generated origin.
    pub fn gen(data: Data) -> Self {
        Self { data, origin: NodeOrigin::Generated }
    }

    /// Get the node ID of this node.
    pub fn node(&self) -> Option<AstNodeId> {
        self.origin.node()
    }

    /// Get the span of this node.
    pub fn span(&self) -> Option<Span> {
        self.node().map(|n| n.span())
    }

    /// Get the source ID of this node.
    pub fn source(&self) -> Option<SourceId> {
        self.node().map(|n| n.source())
    }

    /// Create a new node with the same origin, but different data.
    pub fn with_data<E>(&self, new_data: E) -> Node<E> {
        Node { data: new_data, origin: self.origin }
    }
}

/// A tuple of data and origin can be converted into a node.
impl<D, Data: From<D>> From<(D, NodeOrigin)> for Node<Data> {
    fn from((d, o): (D, NodeOrigin)) -> Self {
        Node::at(d.into(), o)
    }
}

impl<T> HasNodeId for Node<T> {
    fn node_id(&self) -> Option<AstNodeId> {
        match self.origin {
            NodeOrigin::Given(id) | NodeOrigin::InferredFrom(id) => Some(id),
            NodeOrigin::Generated => None,
        }
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum NodeOrigin {
    /// The node was given by the user.
    Given(AstNodeId),
    /// The node was created through type inference of the given origin.
    InferredFrom(AstNodeId),
    /// The node was generated by the compiler, and has no origin.
    Generated,
}

impl NodeOrigin {
    pub fn node(&self) -> Option<AstNodeId> {
        match self {
            NodeOrigin::Given(node) | NodeOrigin::InferredFrom(node) => Some(*node),
            NodeOrigin::Generated => None,
        }
    }

    /// Create a new origin which is inferred from the current one.
    pub fn inferred(&self) -> Self {
        match self {
            NodeOrigin::Given(g) | NodeOrigin::InferredFrom(g) => NodeOrigin::InferredFrom(*g),
            NodeOrigin::Generated => NodeOrigin::Generated,
        }
    }
}
