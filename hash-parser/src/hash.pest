//! Hash language grammar for parsing
//
// All rights reserved 2021 (c) The Hash Language authors

/// Comments
COMMENT = _{ line_comment | block_comment }
line_comment = _{"//" ~ (!NEWLINE ~ ANY)*}
block_comment = _{"/*" ~ (!"*/" ~ ANY)* ~ "*/" }

/// Whitespace
WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }

/// Keywords
if_kw = _{ "if" }
else_kw = _{ "else" }
match_kw = _{ "match" }
let_kw = _{ "let" }
struct_kw = _{ "struct" }
enum_kw = _{ "enum" }
trait_kw = _{ "trait" }
loop_kw = _{ "loop" }
while_kw = _{ "while" }
for_kw = _{ "for" }
in_kw = _{ "in" }
break_kw = _{ "break" }
continue_kw = _{ "continue" }
return_kw = _{ "return" }
import_kw = _{ "import" }
as_kw = _{ "as" }
where_kw = _{ "where" }
keyword = {
    if_kw | else_kw | match_kw | let_kw | struct_kw | enum_kw | trait_kw | loop_kw | while_kw |
    for_kw | in_kw | break_kw | continue_kw | return_kw | import_kw | as_kw | where_kw 
}

/// Silent operators
comma_op = _{ "," }
dot_op = _{ "." }
colon_op = _{ ":" }
semi_op = _{ ";" }
namespace_op = _{ "::" }
underscore_op = _{ "_" }
arrow_op = _{ "=>" }
eq_op = _{ "=" }
spread_op = _{ "..." }
question_op = _{ "?" }

/// Brackets
curly_left = _{ "{" }
curly_right = _{ "}" }
paren_left = _{ "(" }
paren_right = _{ ")" }
square_left = _{ "[" }
square_right = _{ "]" }
angular_left = _{ "<" }
angular_right = _{ ">" }

/// Integer literals
integer_literal = { hex_literal | octal_literal | bin_literal | decimal_literal }
digit_sep = _{ "_" }

decimal_digit = ${ ASCII_DIGIT }
decimal_prefix = _{ "0d" }
decimal_literal = ${ decimal_prefix? ~ decimal_digit ~ (decimal_digit | digit_sep)* }

octal_digit = ${ ASCII_OCT_DIGIT }
octal_prefix = _{ "0o" }
octal_literal = ${ octal_prefix ~ octal_digit ~ (octal_digit | digit_sep)* }

hex_digit = ${ ASCII_HEX_DIGIT }
hex_prefix = _{ "0x" }
hex_literal = ${ hex_prefix ~ hex_digit ~ (hex_digit | digit_sep)* }

bin_digit = ${ ASCII_BIN_DIGIT }
bin_prefix = _{ "0b" }
bin_literal = ${ bin_prefix ~ bin_digit ~ (bin_digit | digit_sep)* }

/// Identifier
ident = @{ "_"* ~ ASCII_ALPHA ~ ("_" | ASCII_ALPHANUMERIC)* }

/// Name and access name
name = { ident }
access_name = { name ~ (namespace_op ~ name)* }

/// Float literal
float_period = _{ "." }
float_part = ${ decimal_digit+ }
float_exp_e = _{ "e" }
float_exp = ${ float_exp_e ~ (add_op | sub_op)? ~ float_part }
float_literal = ${ float_part ~ float_period ~ float_part ~ float_exp? }

/// String literal
string_quote = _{ "\"" }
raw_string = { (!("\\" | "\"") ~ ANY)+ }
string_literal = ${ string_quote ~ (raw_string | escape)* ~ string_quote }

/// Character literal
char_quote = _{ "'" }
char_literal = ${ char_quote ~ (escape | ANY) ~ char_quote }

/// Escaping utilities
predefined = { "n" | "r" | "t" | "\\" | "0" | "\"" | "'" }
byte_prefix = _{ "x" }
unicode_prefix = _{ "u" }
unicode_grp_left = _{ "{" }
unicode_grp_right = _{ "}" }
byte = { byte_prefix ~ hex_digit{2} }
unicode = { unicode_prefix ~ unicode_grp_left ~ hex_digit{1, 6} ~ unicode_grp_right }
escape_prefix = _{ "\\" }
escape = ${ escape_prefix ~ (predefined | byte | unicode) }

/// Bracketed literals
list_literal = { square_left ~ (square_right | expr ~ (comma_op ~ expr)* ~ comma_op? ~ square_right)}
set_literal = { curly_left ~ (comma_op ~ &curly_right | expr ~ comma_op ~ &curly_right | (expr ~ (comma_op ~ expr)* ~ comma_op?)) ~ curly_right }
tuple_literal = { paren_left ~ (comma_op ~ &paren_right | expr ~ comma_op ~ &paren_right | (expr ~ (comma_op ~ expr)* ~ comma_op?)) ~ paren_right}
map_entry = { expr ~ colon_op ~ expr }
map_literal = { curly_left ~ (colon_op ~ &curly_right) | (map_entry ~ (comma_op ~ map_entry)* ~ comma_op?) ~ curly_right ) }

/// Function literal
fn_param = { name ~ (colon_op ~ type_t)? }
fn_params = { paren_left ~ (fn_param ~ (comma_op ~ fn_param)*)? ~ paren_right }
fn_return_ty = { colon_op ~ type_t }
fn_body = { arrow_op ~ expr }
fn_literal = { fn_params ~ fn_return_ty? ~ fn_body }

/// Struct literal
struct_literal_field = { name ~ eq_op ~ expr }
struct_literal = { access_name ~ type_args? ~ curly_left ~ (curly_right | struct_literal_field? ~ (comma_op ~ struct_literal_field)* ~ comma_op? ~ curly_right) }

/// Operators

/// Assignment operators
assign_eq_op = { "=" } // Differs from eq_op --- it is not hidden.
add_eq_op = { "+=" }
sub_eq_op = { "-=" }
mul_eq_op = { "*=" }
div_eq_op = { "/=" }
mod_eq_op = { "%=" }
andl_eq_op = { "&&=" }
orl_eq_op = { "||=" }
andb_eq_op = { "&=" }
orb_eq_op = { "|=" }
xorb_eq_op = { "^=" }
assign_op = { assign_eq_op | add_eq_op | sub_eq_op | mul_eq_op | div_eq_op | mod_eq_op | andl_eq_op | orl_eq_op | andb_eq_op | orb_eq_op | xorb_eq_op }

/// Binary operators
triple_eq_op = { "===" }
double_eq_op = { "==" }
neq_op = { "!=" }
double_neq_op = { "!==" }
add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "/" }
mod_op = { "%" }
andl_op = { "&&" }
orl_op = { "||" }
shl_op = { "<<" }
shr_op = { ">>" }
exp_op = { "**" }
gt_op = { ">" }
lt_op = { "<" }
geq_op = { ">=" }
leq_op = { "<=" }
andb_op = { "&" }
orb_op = { "|" }
xorb_op = { "^" }
not_op = { "!" }
notb_op = { "~" }
neg_op = { "-" }

/// Operator groups
eq_neq_op = { triple_eq_op | double_eq_op | double_neq_op | neq_op }
add_sub_op = { add_op | sub_op }
mul_div_op = { mul_op | div_op | mod_op }
rel_op = { leq_op | geq_op | lt_op | gt_op }
unary_op = { not_op | notb_op | neg_op }

/// Types
type_t = { 
    named_type |
    infer_type |
    function_type |
    tuple_type |
    list_type |
    set_type |
    map_type |
    existential_type
}

/// Literal types
set_type = { curly_left ~ type_t ~ curly_right }
map_type = { curly_left ~ type_t ~ colon_op ~ type_t curly_right }
list_type = { square_left ~ type_t ~ square_right }
tuple_type = { paren_left ~ (comma_op ~ &paren_right | type_t ~ comma_op ~ &paren_right | type_t ~ (comma_op ~ type_t)*) ~ paren_right }

/// Function type
fn_type_args = { left_paren ~ (type_t ~ (comma_op ~ type_t)*)? ~ right_paren }
fn_type = { fn_type_args ~ arrow_op ~ type_t }

/// Special types
existential_type = { question_op }
infer_type       = { underscore_op }

/// Type arguments
type_args   = { angular_left ~ type_t ~ (comma_op ~ type_t)* ~ angular_right }
trait_bound = { access_name ~ type_args? }
bound       = { type_args ~ (where_kw ~ trait_bound+)? }

/// Named type
named_type = { access_name ~ type_args? } // this also handles type variables

/// Statements

/// Import statement
import_st = { import_kw ~ paren_left ~ string_literal ~ paren_right }

/// Assignment statement
assign_st = { expr ~ assignment_operator ~ expr }

/// Let statement
let_st   = { let_kw ~ exhaustive_pattern ~ trait_bound? ~ (":" ~ type_t)? ~ ("=" ~ expr)?}


/// Grammar representation of a struct which includes the name of the struct with a
/// ForAll to specify any bounds or and generic arguments to the struct, with
/// zero or more struct fields. An example for a struct would be:
///
/// struct Name = <T,Q> where eq<T> => { ... };
///        ^^^^    ^──────^^─┬──^        ^^^
/// Name of struct        For all       fields

/// Struct definition
struct_def_field = { name ~ type_annot_op ~ type_t ~ (struct_field_assign ~ expr)? }
struct_def = { struct_kw ~ name ~ eq_op ~ (trait_bound ~ arrow_op)? ~ "{" ~ (struct_field?  ~ (comma ~ struct_field)*)? ~ comma? ~ "}" }


/// Grammar representation for an enum, An enum is constrcuted by a the keyword 'enum'
/// follwed by an identifier name, a for-all declaratation, followed by some enum fields.
/// An enumeration can be made of zero or more enum fields, an example declaration of
/// For example, a declaration of an enun would be:
///
/// enum Name = <T,Q> where eq<T> => { ... };
///      ^^^^    ^──────^^─┬──^        ^^^
/// Name of enum        bound       fields
enum_field = {ident ~ ("(" ~ (type_t ~ (comma ~ type_t)*)? ~ ")")? }
enum_def   = {"enum" ~ ident  ~ "=" ~ (trait_bound ~ "=>")? ~ "{" ~ (enum_field?  ~ (comma ~ enum_field)*)? ~ comma? ~ "}" }



/// Grammar representation of a trait statement. A trait statement
/// is essentially a function with no body, with a for-all node and
/// some genetic type arguments. For example,
///
/// trait eq = <T> => (T, T) => bool;
///     ┌─^^ ^─┐   ^─ ─ ─ ─ ─ ─ ─ ┐
///   name   Generic type args    Function type definition
trait_def   = {"trait" ~ ident ~ "=" ~ trait_bound ~ "=>" ~ type_t}

/// Intrinsic parsing, prefixed by '#' some identifier. There must be no spaces between
/// the '#' and the ident, hence this grammar is atomic.
intrinsic = @{"#" ~ ident}

/// Parse a property access (period followed by a name)
index           = {"[" ~ expr ~ "]"}
property_access = {ident ~ index? ~ ("." ~ (ident ~ index?))*} // @@Cleanup: probably don't want to check for infix function calls here


/// Grammar representation for a funtction call with the potential for specifying
/// generic arguments and a list of actual arguments to the function. For example:
///
/// function_call<int, str>(some, arguments, for, func);
///              ^^^^^^^^^^ ^---------^-------^-----^
///           Type arguments to call        Function call arguments
function_call = {callable_expr ~ type_args? ~ "(" ~ expr? ~ (comma ~ expr)* ~ ")"}

/// Callable expr is used as a workaround for pest-LR limitation
callable_expr = {
    block                     |
    intrinsic                 |
    property_access           |
    "(" ~ function_call ~ ")" | // @@Cleanup: find a way around having to add braces to expr
    access_name               
}


/// Loop constructs
loop_statement  = {"loop" ~ block}
while_statement = {"while" ~ expr ~ body_block}
for_statement   = {"for" ~ exhaustive_pattern ~ "in" ~ expr ~ body_block}

/// patterns sub grammars 
struct_pattern    = {ident ~ "{" ~ (ident ~ (comma ~ ident)*)? ~ "}"}
namespace_pattern = {"{" ~ (name ~ (comma ~ name)*)? ~ "}"}
enum_pattern      = {ident ~ "(" ~ pattern ~ (comma ~ pattern)* ~ ")" }

/// Exhaustive patterns are those that are guaranteed to have a finite
/// number of variants (level 1)
exhaustive_pattern = {
    ident             | // binding pattern
    struct_pattern    |
    namespace_pattern |
    ("(" ~ (name ~ (comma ~ name)*)? ~ ")") // tuple pattern
}


braced_pattern = _{ "(" ~ pattern ~ ")" }
ignore_pattern = _{"_"}

/// Single pattern combinator is used as a combinator for match
/// statements where multiple patterns can be specified for a 
/// switch case. 
single_pattern = { 
    braced_pattern     |
    enum_pattern       |
    exhaustive_pattern |
    ignore_pattern     |
    literal
}

/// The pattern grammar
pattern = {single_pattern ~ ("if" ~ expr)? ~ ("|" ~ pattern)?}

/// Conditional if expression grammar
if_statement = {"if" ~ expr ~ block ~ ("else" ~ (if_statement | block))?}

/// Conditional match expression grammar
match_case      = {pattern ~ "=>" ~ expr}
match_statement = {"match" ~ expr ~ "{" ~ (match_case ~ semi)* ~ "}"}

/// Body block grammar, body blocks can be used within any kind
/// of expression to denote a body of a particular expression.
/// The expression at the end is used as a implicit 'return' statement
/// from the given body block.
body_block = { "{" ~  statement* ~ expr? ~ "}" }

/// Block
block = { 
    if_statement    |
    match_statement |
    for_statement   |
    while_statement | 
    loop_statement  |
    body_block
}

/// Grammar representation for a literals
literal = {
    string_literal   |
    float_literal    |
    integer_literal  |
    char_literal     |
    fn_literal       |
    struct_literal   |
    list_literal     |
    tuple_literal    |
    map_literal      |
    set_literal   
}


/// Grammar representation of some logical operation involving a 
/// unary or a binary expression
binary_expr = {expr_inner ~ (binary_operator ~ expr_inner)+ }
unary_expr = {unary_operator ~ expr}

/// Grammar represenation for an expression which is a single part of a statement.
/// The 'inner' part is a workaround for not being able to use LR grammars.
expr_inner = {
    literal         |
    block           |
    function_call   |
    unary_expr      |
    intrinsic       |
    property_access |
    access_name // variable
}

/// Grammar for an expression, can either be a binary expression which refers
/// to two expressions joined by a binary operator, or a single expression
/// that can be some other variant of an expression.
expr = _{binary_expr | expr_inner ~ (as_op ~ type_t)? | import}


return_statement   = { "return" ~ expr? }
break_statement    = { "break" }
continue_statement = { "continue" }

/// Statement
statement = _{
    block |
    (decl              |
    return_statement   |
    break_statement    |
    continue_statement |
    struct_def         |
    enum_def           |
    trait_def          |
    assign             |
    expr ) ~ ";"
}

/// Module grammar
module = _{ SOI ~ statement* ~ EOI }

