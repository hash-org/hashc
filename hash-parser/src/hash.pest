//! Hash language grammar for parsing
//
// All rights reserved 2021 (c) The Hash Language authors

/// Comments
COMMENT = _{ line_comment | block_comment }
line_comment = _{"//" ~ (!NEWLINE ~ ANY)*}
block_comment = _{"/*" ~ (!"*/" ~ ANY)* ~ "*/" }

/// Whitespace
WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }

/// ---- Keywords ----
if_kw = _{ "if" }
else_kw = _{ "else" }
match_kw = _{ "match" }
let_kw = _{ "let" }
struct_kw = _{ "struct" }
enum_kw = _{ "enum" }
trait_kw = _{ "trait" }
loop_kw = _{ "loop" }
while_kw = _{ "while" }
for_kw = _{ "for" }
in_kw = _{ "in" }
break_kw = _{ "break" }
continue_kw = _{ "continue" }
return_kw = _{ "return" }
import_kw = _{ "import" }
as_kw = _{ "as" }
where_kw = _{ "where" }
keyword = {
    if_kw       |
    else_kw     |
    match_kw    |
    let_kw      |
    struct_kw   |
    enum_kw     |
    trait_kw    |
    loop_kw     |
    while_kw    |
    for_kw      |
    in_kw       |
    break_kw    |
    continue_kw |
    return_kw   |
    import_kw   |
    as_kw       |
    where_kw
}

/// ---- Silent operators ----
comma_op = _{ "," }
dot_op = _{ "." }
colon_op = _{ ":" }
semi_op = _{ ";" }
namespace_op = _{ "::" }
underscore_op = _{ "_" }
arrow_op = _{ "=>" }
eq_op = _{ "=" }
spread_op = _{ "..." }
question_op = _{ "?" }
pipe_op = _{ "|" }

/// ---- Brackets ----
curly_left = _{ "{" }
curly_right = _{ "}" }
paren_left = _{ "(" }
paren_right = _{ ")" }
square_left = _{ "[" }
square_right = _{ "]" }
angular_left = _{ "<" }
angular_right = _{ ">" }

/// ---- Names ----

/// Identifier
ident_first_char = _{ "_" | ASCII_ALPHA }
ident_char = _{ "_" | ASCII_ALPHANUMERIC }
ident = @{ !( "_" ~ !ident_first_char ) ~ ident_first_char ~ ident_char* }

/// Name and access name
keyword_ident = @{ keyword ~ !ident_char } // Used to prevent keywords being used as identifiers.
name = _{ !keyword_ident ~ ident }
access_name = { name ~ (namespace_op ~ name)* }

/// ---- Literals ----

/// Integer literals
integer_literal = { hex_literal | octal_literal | bin_literal | decimal_literal }
digit_sep = _{ "_" }

/// Octal
octal_digit = _{ ASCII_OCT_DIGIT }
octal_prefix = _{ "0o" }
octal_value = ${octal_digit ~ (octal_digit | digit_sep)*}
octal_literal = ${ octal_prefix ~ octal_value }

/// Hexadecimal
hex_digit = _{ ASCII_HEX_DIGIT }
hex_prefix = _{ "0x" }
hex_value = ${hex_digit ~ (hex_digit | digit_sep)*}
hex_literal = ${ hex_prefix ~ hex_value }

/// Binary
bin_digit = _{ ASCII_BIN_DIGIT }
bin_prefix = _{ "0b" }
bin_value = ${bin_digit ~ (bin_digit | digit_sep)* }
bin_literal = ${ bin_prefix ~ bin_value }

/// Shared definitions between decimal and float
num_part = @{ decimal_digit ~ (decimal_digit | digit_sep)* }
exp      = _{ "e" }
sign     = _{add_op | sub_op}
exp_part =  ${ exp ~ sign? ~ num_part }

/// Decimal
decimal_digit = _{ ASCII_DIGIT }
decimal_prefix = _{ "0d" }
decimal_literal = ${ decimal_prefix? ~ num_part }

/// Float literal
float_period = _{ "." }
float_component = ${num_part ~ float_period ~ num_part}
float_literal = ${ float_component ~ exp_part? }

/// String literal
string_quote = _{ "\"" }
raw_string = { (!("\\" | "\"") ~ ANY)+ }
string_literal = ${ string_quote ~ (raw_string | escape)* ~ string_quote }

/// Character literal
char_quote = _{ "'" }
char_literal = ${ char_quote ~ (escape | ANY) ~ char_quote }

/// Escaping utilities
predefined = { "n" | "r" | "t" | "\\" | "0" | "\"" | "'" }
byte_prefix = _{ "x" }
unicode_prefix = _{ "u" }
unicode_grp_left = _{ "{" }
unicode_grp_right = _{ "}" }
byte = { byte_prefix ~ hex_digit{2} }
unicode = { unicode_prefix ~ unicode_grp_left ~ hex_digit{1, 6} ~ unicode_grp_right }
escape_prefix = _{ "\\" }
escape = ${ escape_prefix ~ (predefined | byte | unicode) }

/// Bracketed literals
list_literal = { square_left ~ (square_right | expr ~ (comma_op ~ expr)* ~ comma_op? ~ square_right)}
set_literal = { curly_left ~ (comma_op ~ &curly_right | expr ~ comma_op ~ &curly_right | (expr ~ (comma_op ~ expr)* ~ comma_op?)) ~ curly_right }
tuple_literal = { paren_left ~ (comma_op ~ &paren_right | expr ~ comma_op ~ &paren_right | (expr ~ (comma_op ~ expr)* ~ comma_op?)) ~ paren_right }
map_entry = { expr ~ colon_op ~ expr }
map_literal = { curly_left ~ ((colon_op ~ &curly_right) | (map_entry ~ (comma_op ~ map_entry)* ~ comma_op?)) ~ curly_right }

/// Function literal
fn_param = { name ~ (colon_op ~ any_type)? }
fn_params = { paren_left ~ (fn_param ~ (comma_op ~ fn_param)*)? ~ paren_right }
fn_return_ty = _{ colon_op ~ any_type }
fn_body = { arrow_op ~ expr }
fn_literal = { fn_params ~ fn_return_ty? ~ fn_body }

/// Struct literal
struct_literal_field = { name ~ eq_op ~ expr }
struct_literal_fields = {curly_left ~ (struct_literal_field ~ (comma_op ~ struct_literal_field)* ~ comma_op?)* ~ curly_right }
struct_literal = { access_name ~ type_args? ~ struct_literal_fields }

/// ---- Operators ----

/// Assignment operators
assign_eq_op = { "=" } // Differs from eq_op --- it is not hidden.
add_eq_op = { "+=" }
sub_eq_op = { "-=" }
mul_eq_op = { "*=" }
div_eq_op = { "/=" }
mod_eq_op = { "%=" }
andl_eq_op = { "&&=" }
orl_eq_op = { "||=" }
andb_eq_op = { "&=" }
orb_eq_op = { "|=" }
xorb_eq_op = { "^=" }
assign_op = { 
    assign_eq_op |
    add_eq_op    |
    sub_eq_op    |
    mul_eq_op    |
    div_eq_op    |
    mod_eq_op    |
    andl_eq_op   |
    orl_eq_op    |
    andb_eq_op   |
    orb_eq_op    |
    xorb_eq_op 
}

/// Binary operators
triple_eq_op = { "===" }
double_eq_op = { "==" }
double_neq_op = { "!==" }
neq_op = { "!=" }
add_op = { "+" }
sub_op = { "-" }
mul_op = { "*" }
div_op = { "/" }
mod_op = { "%" }
andl_op = { "&&" }
orl_op = { "||" }
shl_op = { "<<" }
shr_op = { ">>" }
exp_op = { "**" }
gt_op = { ">" }
lt_op = { "<" }
geq_op = { ">=" }
leq_op = { "<=" }
andb_op = { "&" }
orb_op = { "|" }
xorb_op = { "^" }
binary_op = { 
    triple_eq_op  |
    double_eq_op  |
    double_neq_op |
    neq_op        |
    add_op        |
    sub_op        |
    mul_op        |
    div_op        |
    mod_op        |
    andl_op       |
    orl_op        |
    shl_op        |
    shr_op        |
    exp_op        |
    geq_op        |
    leq_op        |
    gt_op         |
    lt_op         |
    andb_op       |
    orb_op        |
    xorb_op       
}

/// Unary operators
not_op = { "!" }
notb_op = { "~" }
pos_op = {"+"}
neg_op = { "-" }
unary_op = { not_op | notb_op | neg_op | pos_op }

/// ---- Types ----

/// Literal types
set_type = { curly_left ~ any_type ~ curly_right }
map_type = { curly_left ~ any_type ~ colon_op ~ any_type ~ curly_right }
list_type = { square_left ~ any_type ~ square_right }
tuple_type = { paren_left ~ (comma_op ~ &paren_right | any_type ~ comma_op ~ &paren_right | any_type ~ (comma_op ~ any_type)*) ~ paren_right }

/// Function type
fn_type_args = { paren_left ~ (any_type ~ (comma_op ~ any_type)*)? ~ paren_right }
fn_type = { fn_type_args ~ arrow_op ~ any_type }

/// Special types
existential_type = { question_op }
infer_type = { underscore_op }

/// Type arguments
type_args = { angular_left ~ any_type ~ (comma_op ~ any_type)* ~ angular_right }
trait_bound = { access_name ~ type_args? }
where_traits = { where_kw ~ trait_bound ~ (comma_op ~ trait_bound)* }
bound = { type_args ~ where_traits? }

/// Named type
named_type = { access_name ~ type_args? } // this also handles type variables

/// Any type
any_type = { 
    named_type |
    infer_type |
    fn_type    |
    tuple_type |
    list_type  |
    set_type   |
    map_type   |
    existential_type
}

/// ---- Expressions ----

/// Intrinsic expression (#identifier)
intrinsic_expr = @{ "#" ~ name }

/// Import expression
import_expr = { import_kw ~ paren_left ~ string_literal ~ paren_right }

/// Variable
variable_expr = { access_name ~ type_args? }

/// Parenthesised expression
paren_expr = { paren_left ~ expr ~ paren_right }

/// Literal expression
literal_expr = {
    string_literal  |
    float_literal   |
    integer_literal |
    char_literal    |
    fn_literal      |
    list_literal    |
    tuple_literal   |
    map_literal     |
    set_literal 
}

/// Expression which can be the subject of a function call/prop-access/index.
subject_expr = {
    intrinsic_expr |
    import_expr    |
    literal_expr   |
    variable_expr  |
    paren_expr
}

/// Index
index_arg = { square_left ~ expr ~ square_right }

/// Function call
fn_args = { paren_left ~ expr? ~ (comma_op ~ expr)* ~ paren_right }

/// Property access
property_access = { dot_op ~ name }

/// Single term expression
single_expr = { subject_expr ~ (property_access | fn_args | index_arg)* }

/// Unary expression
unary_expr = { unary_op ~ unary_expr | single_expr }

/// Typed expression (as)
typed_expr = { unary_expr ~ ( as_kw ~ any_type )? }

/// Binary expression
binary_expr = { typed_expr ~ ( binary_op ~ typed_expr )* }

/// Block expression
block_expr = _{ block }

/// Struct literal
/// Placed outside of other literals to prevent blocks being parsed as struct
/// expressions.
struct_expr = { struct_literal }

/// Any expression
expr = { block_expr | ( &struct_literal ~ struct_literal ) | binary_expr }

/// ---- Patterns ----

/// Binding pattern
binding_pattern = { name }

/// Struct pattern
struct_pattern_field = { name ~ (eq_op ~ pattern)? }
struct_pattern_fields = { curly_left ~ (struct_pattern_field ~ (comma_op ~ struct_pattern_field)*)? ~ curly_right }
struct_pattern = { access_name ~ struct_pattern_fields }

/// Enum pattern
enum_pattern_args = { paren_left ~ pattern ~ (comma_op ~ pattern)* ~ paren_right }
enum_pattern = { access_name ~ enum_pattern_args }

/// Namespace pattern
namespace_pattern_field = { name ~ (colon_op ~ pattern)? }
namespace_pattern = { curly_left ~ (namespace_pattern_field ~ (comma_op ~ namespace_pattern_field)*)? ~ curly_right }

/// Tuple pattern
tuple_pattern = { paren_left ~ (comma_op ~ &paren_right | pattern ~ comma_op ~ &paren_right | (pattern ~ (comma_op ~ pattern)* ~ comma_op?)) ~ paren_right }

/// Ignore pattern
ignore_pattern = { underscore_op }

/// Grouped pattern (1 | 2)
grouped_pattern = { paren_left ~ pattern ~ paren_right }

/// Literal pattern
literal_pattern = {
    string_literal  |
    float_literal   |
    integer_literal |
    char_literal    
}

/// Single pattern (used in binding positions)
single_pattern = {
    enum_pattern    |
    binding_pattern |
    ignore_pattern  |
    struct_pattern  |
    literal_pattern |
    tuple_pattern   |
    grouped_pattern |
    namespace_pattern 
}

/// Compound pattern (matches a series of single patterns)
compound_pattern = _{ single_pattern ~ (pipe_op ~ single_pattern)* }

/// Any pattern (includes optional if condition)
pattern = { compound_pattern ~ (if_kw ~ expr)? }

/// ---- Blocks ----

/// Body block
/// Zero or one statements followed by zero or one expression.
//
// Quirk: the expression might not get parsed if it is a block, because it will
// get parsed as a statement. Correct transformation should happen during AST
// translation.
body_block = { curly_left ~ statement* ~ expr? ~ curly_right }

/// If-else block
else_block = { else_kw ~ body_block }
else_if_block = _{ else_kw ~ if_block }
if_block = { if_kw ~ expr ~ body_block }
if_else_block = { if_block ~ else_if_block* ~ else_block? }

/// Match block
match_case = { pattern ~ arrow_op ~ expr }
match_cases = { curly_left ~ (match_case ~ semi_op)* ~ curly_right }
match_block = { match_kw ~ expr ~ match_cases }

/// Loop blocks
loop_block = { loop_kw ~ body_block }
while_block = { while_kw ~ expr ~ body_block}
for_block = { for_kw ~ single_pattern ~ in_kw ~ expr ~ body_block}

/// Block
block = { 
    if_else_block |
    match_block   |
    loop_block    |
    while_block   |
    for_block     |
    body_block
}

/// ---- Statements ----

/// Break, return, continue
return_st = { return_kw ~ expr? }
break_st = { break_kw }
continue_st = { continue_kw }

/// Block statement
block_st = _{ block }

/// Let statement
let_st = { let_kw ~ single_pattern ~ bound? ~ (colon_op ~ any_type)? ~ (eq_op ~ expr)?}

/// Assignment or expression statement
expr_or_assign_st = { expr ~ (assign_op ~ expr)? }

/// Struct definition
struct_def_field = { name ~ colon_op ~ any_type ~ (eq_op ~ expr)? }
struct_def_fields = { curly_left ~ (struct_def_field? ~ (comma_op ~ struct_def_field)*)? ~ comma_op? ~ curly_right }
struct_def = { struct_kw ~ name ~ eq_op ~ (bound ~ arrow_op)? ~ struct_def_fields }

/// Enum definition
enum_field = { name ~ (paren_left ~ (any_type ~ (comma_op ~ any_type)*)? ~ paren_right)? }
enum_fields = { curly_left ~ (enum_field? ~ (comma_op ~ enum_field)*)? ~ comma_op? ~ curly_right }
enum_def = { enum_kw ~ name ~ eq_op ~ (bound ~ arrow_op)? ~ enum_fields }

/// Trait definition
trait_def = { trait_kw ~ name ~ eq_op ~ bound ~ arrow_op ~ any_type }

/// Semicolon-ending statement
semi_st = _{
    ( break_st | return_st | continue_st | let_st | expr_or_assign_st | struct_def | enum_def | trait_def ) ~ semi_op
}

/// Statement
statement = { block_st | semi_st }

/// ---- Module (entry point) ----
module = _{ SOI ~ statement* ~ EOI }

